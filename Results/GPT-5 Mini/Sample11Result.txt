GenerationId:
gen-1765218220-NFBqZ2j6pKLS0sQ6DTci

Content:
```csharp
using System;
using Xunit;
using Dataset.Sample11;

namespace Dataset.Sample11.UnitTests
{
    public class MatrixChainMultiplicationTests
    {
        [Fact]
        public void MatrixChainOrder_SimpleTwoMatrices_ReturnsCorrectCostAndS()
        {
            // Arrange
            int[] p = { 10, 20, 30 };
            int n = 3;

            // Act
            int cost = MatrixChainMultiplication.MatrixChainOrder(p, n, out int[,] s);

            // Assert
            Assert.Equal(6000, cost);
            Assert.NotNull(s);
            Assert.Equal(1, s[1, 2]);
            string parentheses = MatrixChainMultiplication.GetOptimalParentheses(s, 1, 2);
            Assert.Equal("(A1A2)", parentheses);
        }

        [Fact]
        public void MatrixChainOrder_ClassicExample_ReturnsKnownMinimumAndParentheses()
        {
            // Arrange
            int[] p = { 30, 35, 15, 5, 10, 20, 25 };
            int n = 7;

            // Act
            int cost = MatrixChainMultiplication.MatrixChainOrder(p, n, out int[,] s);

            // Assert
            Assert.Equal(15125, cost);
            Assert.NotNull(s);
            string parentheses = MatrixChainMultiplication.GetOptimalParentheses(s, 1, n - 1);
            Assert.Equal("((A1(A2A3))((A4A5)A6))", parentheses);
            // ensure input array not modified
            Assert.Equal(new int[] { 30, 35, 15, 5, 10, 20, 25 }, p);
        }

        [Fact]
        public void MatrixChainOrder_InvalidN_ThrowsIndexOutOfRangeException()
        {
            // Arrange
            int[] p = { 10, 20 };
            int n = 1;

            // Act & Assert
            Assert.Throws<IndexOutOfRangeException>(() => MatrixChainMultiplication.MatrixChainOrder(p, n, out _));
        }

        [Fact]
        public void GetOptimalParentheses_SingleElement_ReturnsSingleName()
        {
            // Arrange
            int[,] s = new int[2, 2]; // indices 0..1, but we will call i==j==1
            int i = 1;
            int j = 1;

            // Act
            string result = MatrixChainMultiplication.GetOptimalParentheses(s, i, j);

            // Assert
            Assert.Equal("A1", result);
        }

        [Fact]
        public void GetOptimalParentheses_NullS_ThrowsNullReferenceException()
        {
            // Arrange
            int[,] s = null;

            // Act & Assert
            Assert.Throws<NullReferenceException>(() => MatrixChainMultiplication.GetOptimalParentheses(s, 1, 1));
        }

        [Fact]
        public void GetOptimalParentheses_CustomS_ConstructsExpectedParentheses()
        {
            // Arrange
            // Build s for a chain of 3 matrices where optimal split is between 1 and 2:
            // Desired parentheses: (A1(A2A3))
            int[,] s = new int[4, 4];
            s[1, 3] = 1;
            s[1, 1] = 0;
            s[2, 3] = 2;

            // Act
            string result = MatrixChainMultiplication.GetOptimalParentheses(s, 1, 3);

            // Assert
            Assert.Equal("(A1(A2A3))", result);
        }
    }
}
```

ElapsedTimeMilliseconds:
25174,914

OpenRouterElapsedTimeMilliseconds:
41863

PromptTokens:
1311

CompletionTokens:
2055

TotalTokens:
3366

TotalCost:
0,00443775