<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\Programming\Projects\LlmUnitTestGenerationArtifacts\Gemini3ProUnitTests\Sample13Tests.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using Dataset.Sample13;
using NSubstitute;

namespace Gemini3ProUnitTests;

public class OntologyHelperTests
{
    [Fact]
    public void ParseNode_WhenNodeTypeIsUriAndContainsHash_ReturnsStringAfterHash()
    {
        // Arrange
        var expectedResult = &quot;MyResource&quot;;
        var rawString = $&quot;http://example.org/ontology#{expectedResult}&quot;;

        var node = Substitute.For&lt;INode&gt;();
        node.NodeType.Returns(NodeType.Uri);
        node.ToString().Returns(rawString);

        // Act
        var result = node.ParseNode();

        // Assert
        Assert.Equal(expectedResult, result);
    }

    [Fact]
    public void ParseNode_WhenNodeTypeIsUriAndIsUrlEncoded_ReturnsUnescapedStringAfterHash()
    {
        // Arrange
        var rawString = &quot;http%3A%2F%2Fexample.org%2Fontology%23MyResource&quot;;
        // Decoded: http://example.org/ontology#MyResource
        var expectedResult = &quot;MyResource&quot;;

        var node = Substitute.For&lt;INode&gt;();
        node.NodeType.Returns(NodeType.Uri);
        node.ToString().Returns(rawString);

        // Act
        var result = node.ParseNode();

        // Assert
        Assert.Equal(expectedResult, result);
    }

    [Fact]
    public void ParseNode_WhenNodeTypeIsUriAndDoesNotContainHash_ReturnsFullString()
    {
        // Arrange
        // Logic analysis: IndexOf returns -1. Substring(-1 + 1) = Substring(0).
        var rawString = &quot;http://example.org/ontology/MyResource&quot;;

        var node = Substitute.For&lt;INode&gt;();
        node.NodeType.Returns(NodeType.Uri);
        node.ToString().Returns(rawString);

        // Act
        var result = node.ParseNode();

        // Assert
        Assert.Equal(rawString, result);
    }

    [Fact]
    public void ParseNode_WhenNodeTypeIsUriAndToStringReturnsNull_ReturnsEmptyString()
    {
        // Arrange
        var node = Substitute.For&lt;INode&gt;();
        node.NodeType.Returns(NodeType.Uri);
        node.ToString().Returns((string?)null);

        // Act
        var result = node.ParseNode();

        // Assert
        Assert.Equal(string.Empty, result);
    }

    [Fact]
    public void ParseNode_WhenNodeTypeIsLiteralAndContainsCaret_ReturnsStringBeforeCaret()
    {
        // Arrange
        var expectedResult = &quot;SomeValue&quot;;
        var rawString = $&quot;{expectedResult}^^xsd:string&quot;;

        var node = Substitute.For&lt;INode&gt;();
        node.NodeType.Returns(NodeType.Literal);
        node.ToString().Returns(rawString);

        // Act
        var result = node.ParseNode();

        // Assert
        Assert.Equal(expectedResult, result);
    }

    [Fact]
    public void ParseNode_WhenNodeTypeIsLiteralAndIsUrlEncoded_ReturnsUnescapedStringBeforeCaret()
    {
        // Arrange
        var rawString = &quot;SomeValue%5Exsd%3Astring&quot;;
        // Decoded: SomeValue^xsd:string
        var expectedResult = &quot;SomeValue&quot;;

        var node = Substitute.For&lt;INode&gt;();
        node.NodeType.Returns(NodeType.Literal);
        node.ToString().Returns(rawString);

        // Act
        var result = node.ParseNode();

        // Assert
        Assert.Equal(expectedResult, result);
    }

    [Fact]
    public void ParseNode_WhenNodeTypeIsLiteralAndDoesNotContainCaret_ThrowsArgumentOutOfRangeException()
    {
        // Arrange
        // Logic analysis: IndexOf returns -1. Substring(0, -1) throws ArgumentOutOfRangeException.
        var rawString = &quot;JustValueHere&quot;;

        var node = Substitute.For&lt;INode&gt;();
        node.NodeType.Returns(NodeType.Literal);
        node.ToString().Returns(rawString);

        // Act &amp; Assert
        Assert.Throws&lt;ArgumentOutOfRangeException&gt;(() =&gt; node.ParseNode());
    }

    [Fact]
    public void ParseNode_WhenNodeTypeIsLiteralAndToStringReturnsNull_ThrowsArgumentOutOfRangeException()
    {
        // Arrange
        // Logic analysis: null -&gt; string.Empty -&gt; IndexOf returns -1 -&gt; Substring(0, -1) throws.
        var node = Substitute.For&lt;INode&gt;();
        node.NodeType.Returns(NodeType.Literal);
        node.ToString().Returns((string?)null);

        // Act &amp; Assert
        Assert.Throws&lt;ArgumentOutOfRangeException&gt;(() =&gt; node.ParseNode());
    }

    [Theory]
    [InlineData(NodeType.Blank)]
    [InlineData(NodeType.GraphLiteral)]
    [InlineData(NodeType.Variable)]
    [InlineData(NodeType.Triple)]
    public void ParseNode_WhenNodeTypeIsNotUriOrLiteral_ReturnsEmptyString(NodeType nodeType)
    {
        // Arrange
        var node = Substitute.For&lt;INode&gt;();
        node.NodeType.Returns(nodeType);
        node.ToString().Returns(&quot;SomeValue#Ignored&quot;);

        // Act
        var result = node.ParseNode();

        // Assert
        Assert.Equal(string.Empty, result);
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[10,5,10,6,1],[12,9,12,43,1],[13,9,13,73,1],[15,9,15,44,1],[16,9,16,45,1],[17,9,17,44,1],[20,9,20,39,1],[23,9,23,46,1],[24,5,24,6,1],[28,5,28,6,1],[30,9,30,76,1],[32,9,32,43,1],[34,9,34,44,1],[35,9,35,45,1],[36,9,36,44,1],[39,9,39,39,1],[42,9,42,46,1],[43,5,43,6,1],[47,5,47,6,1],[50,9,50,66,1],[52,9,52,44,1],[53,9,53,45,1],[54,9,54,44,1],[57,9,57,39,1],[60,9,60,41,1],[61,5,61,6,1],[65,5,65,6,1],[67,9,67,44,1],[68,9,68,45,1],[69,9,69,48,1],[72,9,72,39,1],[75,9,75,44,1],[76,5,76,6,1],[80,5,80,6,1],[82,9,82,42,1],[83,9,83,57,1],[85,9,85,44,1],[86,9,86,49,1],[87,9,87,44,1],[90,9,90,39,1],[93,9,93,46,1],[94,5,94,6,1],[98,5,98,6,1],[100,9,100,52,1],[102,9,102,42,1],[104,9,104,44,1],[105,9,105,49,1],[106,9,106,44,1],[109,9,109,39,1],[112,9,112,46,1],[113,5,113,6,1],[117,5,117,6,1],[120,9,120,41,1],[122,9,122,44,1],[123,9,123,49,1],[124,9,124,44,1],[127,9,127,58,1],[127,58,127,74,1],[127,74,127,76,1],[128,5,128,6,1],[132,5,132,6,1],[135,9,135,44,1],[136,9,136,49,1],[137,9,137,48,1],[140,9,140,58,1],[140,58,140,74,1],[140,74,140,76,1],[141,5,141,6,1],[149,5,149,6,1],[151,9,151,44,1],[152,9,152,41,1],[153,9,153,54,1],[156,9,156,39,1],[159,9,159,44,1],[160,5,160,6,1]]);
    </script>
  </body>
</html>