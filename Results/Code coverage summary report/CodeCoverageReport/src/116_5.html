<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\Programming\Projects\LlmUnitTestGenerationArtifacts\DeepSeekR10528UnitTests\Sample11Tests.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using Dataset.Sample11;

namespace DeepSeekR10528UnitTests;

public class MatrixChainMultiplicationTests
{
    [Fact]
    public void MatrixChainOrder_OneMatrix_ReturnsZero()
    {
        // Arrange
        int[] p = { 10, 20 };
        int n = 2;

        // Act
        int cost = MatrixChainMultiplication.MatrixChainOrder(p, n, out int[,] s);

        // Assert
        Assert.Equal(0, cost);
        Assert.NotNull(s);
        Assert.Equal(2, s.GetLength(0));
        Assert.Equal(2, s.GetLength(1));
    }

    [Fact]
    public void MatrixChainOrder_TwoMatrices_Returns6000()
    {
        // Arrange
        int[] p = { 10, 20, 30 };
        int n = 3;

        // Act
        int cost = MatrixChainMultiplication.MatrixChainOrder(p, n, out int[,] s);

        // Assert
        Assert.Equal(6000, cost);
        Assert.NotNull(s);
        Assert.Equal(3, s.GetLength(0));
        Assert.Equal(3, s.GetLength(1));
        Assert.Equal(1, s[1, 2]);
    }

    [Fact]
    public void MatrixChainOrder_ThreeMatrices_Returns7500AndSetsSCorrectly()
    {
        // Arrange
        int[] p = { 10, 100, 5, 50 };
        int n = 4;

        // Act
        int cost = MatrixChainMultiplication.MatrixChainOrder(p, n, out int[,] s);

        // Assert
        Assert.Equal(7500, cost);
        Assert.NotNull(s);
        Assert.Equal(4, s.GetLength(0));
        Assert.Equal(4, s.GetLength(1));
        Assert.Equal(1, s[1, 2]);
        Assert.Equal(2, s[2, 3]);
        Assert.Equal(2, s[1, 3]);
    }

    [Fact]
    public void GetOptimalParentheses_SingleMatrix_ReturnsA1()
    {
        // Arrange
        int[,] s = new int[2, 2];
        int i = 1;
        int j = 1;

        // Act
        string result = MatrixChainMultiplication.GetOptimalParentheses(s, i, j);

        // Assert
        Assert.Equal(&quot;A1&quot;, result);
    }

    [Fact]
    public void GetOptimalParentheses_TwoMatrices_ReturnsParenthesesCorrectly()
    {
        // Arrange
        int[,] s = new int[3, 3];
        s[1, 2] = 1;
        int i = 1;
        int j = 2;

        // Act
        string result = MatrixChainMultiplication.GetOptimalParentheses(s, i, j);

        // Assert
        Assert.Equal(&quot;(A1A2)&quot;, result);
    }

    [Fact]
    public void GetOptimalParentheses_ThreeMatricesSplitAtTwo_ReturnsDoubleParenthesized()
    {
        // Arrange
        int[,] s = new int[4, 4];
        s[1, 2] = 1;
        s[1, 3] = 2;
        int i = 1;
        int j = 3;

        // Act
        string result = MatrixChainMultiplication.GetOptimalParentheses(s, i, j);

        // Assert
        Assert.Equal(&quot;((A1A2)A3)&quot;, result);
    }

    [Fact]
    public void GetOptimalParentheses_ThreeMatricesSplitAtOne_ReturnsAlternateParenthesization()
    {
        // Arrange
        int[,] s = new int[4, 4];
        s[2, 3] = 2;
        s[1, 3] = 1;
        int i = 1;
        int j = 3;

        // Act
        string result = MatrixChainMultiplication.GetOptimalParentheses(s, i, j);

        // Assert
        Assert.Equal(&quot;(A1(A2A3))&quot;, result);
    }

    [Fact]
    public void CombinedMethods_ThreeMatrices_CorrectCostAndParentheses()
    {
        // Arrange
        int[] p = { 10, 100, 5, 50 };
        int n = 4;

        // Act
        int cost = MatrixChainMultiplication.MatrixChainOrder(p, n, out int[,] s);
        string parentheses = MatrixChainMultiplication.GetOptimalParentheses(s, 1, n - 1);

        // Assert
        Assert.Equal(7500, cost);
        Assert.Equal(&quot;((A1A2)A3)&quot;, parentheses);
    }

    [Fact]
    public void CombinedMethods_TwoMatrices_CorrectCostAndParentheses()
    {
        // Arrange
        int[] p = { 10, 20, 30 };
        int n = 3;

        // Act
        int cost = MatrixChainMultiplication.MatrixChainOrder(p, n, out int[,] s);
        string parentheses = MatrixChainMultiplication.GetOptimalParentheses(s, 1, n - 1);

        // Assert
        Assert.Equal(6000, cost);
        Assert.Equal(&quot;(A1A2)&quot;, parentheses);
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[9,5,9,6,1],[11,9,11,30,1],[12,9,12,19,1],[15,9,15,83,1],[18,9,18,31,1],[19,9,19,27,1],[20,9,20,41,1],[21,9,21,41,1],[22,5,22,6,1],[26,5,26,6,1],[28,9,28,34,1],[29,9,29,19,1],[32,9,32,83,1],[35,9,35,34,1],[36,9,36,27,1],[37,9,37,41,1],[38,9,38,41,1],[39,9,39,34,1],[40,5,40,6,1],[44,5,44,6,1],[46,9,46,38,1],[47,9,47,19,1],[50,9,50,83,1],[53,9,53,34,1],[54,9,54,27,1],[55,9,55,41,1],[56,9,56,41,1],[57,9,57,34,1],[58,9,58,34,1],[59,9,59,34,1],[60,5,60,6,1],[64,5,64,6,1],[66,9,66,34,1],[67,9,67,19,1],[68,9,68,19,1],[71,9,71,82,1],[74,9,74,36,1],[75,5,75,6,1],[79,5,79,6,1],[81,9,81,34,1],[82,9,82,21,1],[83,9,83,19,1],[84,9,84,19,1],[87,9,87,82,1],[90,9,90,40,1],[91,5,91,6,1],[95,5,95,6,1],[97,9,97,34,1],[98,9,98,21,1],[99,9,99,21,1],[100,9,100,19,1],[101,9,101,19,1],[104,9,104,82,1],[107,9,107,44,1],[108,5,108,6,1],[112,5,112,6,1],[114,9,114,34,1],[115,9,115,21,1],[116,9,116,21,1],[117,9,117,19,1],[118,9,118,19,1],[121,9,121,82,1],[124,9,124,44,1],[125,5,125,6,1],[129,5,129,6,1],[131,9,131,38,1],[132,9,132,19,1],[135,9,135,83,1],[136,9,136,91,1],[139,9,139,34,1],[140,9,140,49,1],[141,5,141,6,1],[145,5,145,6,1],[147,9,147,34,1],[148,9,148,19,1],[151,9,151,83,1],[152,9,152,91,1],[155,9,155,34,1],[156,9,156,45,1],[157,5,157,6,1]]);
    </script>
  </body>
</html>