<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\Programming\Projects\LlmUnitTestGenerationArtifacts\Glm45AirUnitTests\Sample12Tests.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using Dataset.Sample12;

namespace Glm45AirUnitTests;

public class LUPDecompositionTests
{
    [Fact]
    public void Decompose_PassingNonSquareMatrix_ThrowsArgumentException()
    {
        // Arrange
        double[,] nonSquareMatrix = new double[2, 3];

        // Act &amp; Assert
        Assert.Throws&lt;ArgumentException&gt;(() =&gt; LUPDecomposition.Decompose(nonSquareMatrix, out _, out _, out _));
    }

    [Fact]
    public void Decompose_PassingSingularMatrix_ThrowsInvalidOperationException()
    {
        // Arrange
        double[,] singularMatrix = new double[,]
        {
            { 1, 2 },
            { 2, 4 }
        };

        // Act &amp; Assert
        var exception = Assert.Throws&lt;InvalidOperationException&gt;(() =&gt; LUPDecomposition.Decompose(singularMatrix, out _, out _, out _));
        Assert.Equal(&quot;Матриця є виродженою.&quot;, exception.Message);
    }

    [Fact]
    public void Decompose_PassingValid2x2Matrix_ReturnsCorrectLUP()
    {
        // Arrange
        double[,] matrix = new double[,]
        {
            { 2, 1 },
            { 1, 2 }
        };

        // Act
        LUPDecomposition.Decompose(matrix, out double[,] L, out double[,] U, out int[] P);

        // Assert
        Assert.Equal(2, L.GetLength(0));
        Assert.Equal(2, L.GetLength(1));
        Assert.Equal(2, U.GetLength(0));
        Assert.Equal(2, U.GetLength(1));
        Assert.Equal(2, P.Length);

        // Expected L for this permutation (identity)
        Assert.Equal(1, L[0, 0]);
        Assert.Equal(0, L[0, 1]);
        Assert.Equal(0.5, L[1, 0]);
        Assert.Equal(1, L[1, 1]);

        // Expected U for this permutation
        Assert.Equal(2, U[0, 0]);
        Assert.Equal(1, U[0, 1]);
        Assert.Equal(0, U[1, 0]);
        Assert.Equal(1.5, U[1, 1]);

        // Expected permutation (identity)
        Assert.Equal(0, P[0]);
        Assert.Equal(1, P[1]);
    }

    [Fact]
    public void Decompose_PassingValid3x3Matrix_ReturnsCorrectLUP()
    {
        // Arrange
        double[,] matrix = new double[,]
        {
            { 1, 2, 3 },
            { 4, 5, 6 },
            { 7, 8, 9 }
        };

        // Act
        LUPDecomposition.Decompose(matrix, out double[,] L, out double[,] U, out int[] P);

        // Assert
        Assert.Equal(3, L.GetLength(0));
        Assert.Equal(3, L.GetLength(1));
        Assert.Equal(3, U.GetLength(0));
        Assert.Equal(3, U.GetLength(1));
        Assert.Equal(3, P.Length);

        // Verify L is unit lower triangular
        Assert.Equal(1, L[0, 0]);
        Assert.Equal(0, L[0, 1]);
        Assert.Equal(0, L[0, 2]);
        Assert.Equal(4.0 / 7.0, L[1, 0]);
        Assert.Equal(1, L[1, 1]);
        Assert.Equal(0, L[1, 2]);
        Assert.Equal(1.0 / 7.0, L[2, 0]);
        Assert.Equal(2.0 / 3.0, L[2, 1]);
        Assert.Equal(1, L[2, 2]);

        // Verify U is upper triangular
        Assert.Equal(7, U[0, 0]);
        Assert.Equal(8, U[0, 1]);
        Assert.Equal(9, U[0, 2]);
        Assert.Equal(0, U[1, 0]);
        Assert.Equal(-6.0 / 7.0, U[1, 1]);
        Assert.Equal(-12.0 / 7.0, U[1, 2]);
        Assert.Equal(0, U[2, 0]);
        Assert.Equal(0, U[2, 1]);
        Assert.Equal(0, U[2, 2]);

        // Verify permutation
        Assert.Equal(2, P[0]);
        Assert.Equal(1, P[1]);
        Assert.Equal(0, P[2]);
    }

    [Fact]
    public void Decompose_PassingMatrixRequiringRowSwap_ReturnsCorrectLUP()
    {
        // Arrange
        double[,] matrix = new double[,]
        {
            { 0, 0, 0 },
            { 0, 0, 1 },
            { 0, 1, 0 }
        };

        // Act
        LUPDecomposition.Decompose(matrix, out double[,] L, out double[,] U, out int[] P);

        // Assert
        Assert.Equal(3, L.GetLength(0));
        Assert.Equal(3, L.GetLength(1));
        Assert.Equal(3, U.GetLength(0));
        Assert.Equal(3, U.GetLength(1));
        Assert.Equal(3, P.Length);

        // Expected L (identity after permutation)
        Assert.Equal(1, L[0, 0]);
        Assert.Equal(0, L[0, 1]);
        Assert.Equal(0, L[0, 2]);
        Assert.Equal(0, L[1, 0]);
        Assert.Equal(1, L[1, 1]);
        Assert.Equal(0, L[1, 2]);
        Assert.Equal(0, L[2, 0]);
        Assert.Equal(1, L[2, 1]);
        Assert.Equal(1, L[2, 2]);

        // Expected U (swapped rows)
        Assert.Equal(0, U[0, 0]);
        Assert.Equal(1, U[0, 1]);
        Assert.Equal(0, U[0, 2]);
        Assert.Equal(0, U[1, 0]);
        Assert.Equal(0, U[1, 1]);
        Assert.Equal(1, U[1, 2]);
        Assert.Equal(0, U[2, 0]);
        Assert.Equal(0, U[2, 1]);
        Assert.Equal(0, U[2, 2]);

        // Expected permutation (swapped rows 1 and 2)
        Assert.Equal(0, P[0]);
        Assert.Equal(2, P[1]);
        Assert.Equal(1, P[2]);
    }

    [Theory]
    [InlineData(0, 0)]
    [InlineData(1, 1)]
    [InlineData(2, 2)]
    [InlineData(3, 3)]
    [InlineData(4, 4)]
    public void GetMatrix_PassingSquareMatrix_ReturnsCorrectStringRepresentation(int size, int n)
    {
        // Arrange
        double[,] matrix = new double[n, n];
        for (int i = 0; i &lt; n; i++)
            for (int j = 0; j &lt; n; j++)
                matrix[i, j] = i * n + j;

        // Act
        string result = LUPDecomposition.GetMatrix(matrix);

        // Assert
        string[] lines = result.Split(&#39;\n&#39;, StringSplitOptions.RemoveEmptyEntries);
        Assert.Equal(n, lines.Length);

        for (int i = 0; i &lt; n; i++)
        {
            string[] values = lines[i].Split(&#39;\t&#39;, StringSplitOptions.RemoveEmptyEntries);
            Assert.Equal(n, values.Length);

            for (int j = 0; j &lt; n; j++)
            {
                Assert.Equal((i * n + j).ToString(), values[j]);
            }
        }
    }

    [Fact]
    public void GetMatrix_PassingNonSquareMatrix_ReturnsCorrectStringRepresentation()
    {
        // Arrange
        double[,] matrix = new double[,]
        {
            { 1, 2, 3 },
            { 4, 5, 6 }
        };

        // Act
        string result = LUPDecomposition.GetMatrix(matrix);

        // Assert
        string expected = &quot;1\t2\t3\t\n4\t5\t6\t\n&quot;;
        Assert.Equal(expected, result);
    }

    [Theory]
    [InlineData(new int[] { 0 }, 1)]
    [InlineData(new int[] { 1, 0 }, 2)]
    [InlineData(new int[] { 1, 2, 0 }, 3)]
    [InlineData(new int[] { 3, 2, 1, 0 }, 4)]
    [InlineData(new int[] { 4, 3, 2, 1, 0 }, 5)]
    public void GetPermutationMatrix_PassingValidPermutation_ReturnsCorrectStringRepresentation(int[] P, int n)
    {
        // Arrange
        // Act
        string result = LUPDecomposition.GetPermutationMatrix(P);

        // Assert
        string[] lines = result.Split(&#39;\n&#39;, StringSplitOptions.RemoveEmptyEntries);
        Assert.Equal(n, lines.Length);

        for (int i = 0; i &lt; n; i++)
        {
            string[] values = lines[i].Split(&#39;\t&#39;, StringSplitOptions.RemoveEmptyEntries);
            Assert.Equal(n, values.Length);

            for (int j = 0; j &lt; n; j++)
            {
                Assert.Equal(j == P[i] ? &quot;1&quot; : &quot;0&quot;, values[j]);
            }
        }
    }

    [Fact]
    public void GetPermutationMatrix_PassingEmptyPermutation_ThrowsArgumentException()
    {
        // Arrange
        int[] emptyPermutation = Array.Empty&lt;int&gt;();

        // Act &amp; Assert
        Assert.Throws&lt;ArgumentException&gt;(() =&gt; LUPDecomposition.GetPermutationMatrix(emptyPermutation));
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[9,5,9,6,1],[11,9,11,54,1],[14,9,14,48,1],[14,48,14,112,1],[14,112,14,114,1],[15,5,15,6,0],[19,5,19,6,1],[21,9,25,11,1],[28,9,28,72,1],[28,72,28,135,1],[28,135,28,137,1],[29,9,29,66,0],[30,5,30,6,0],[34,5,34,6,1],[36,9,40,11,1],[43,9,43,91,1],[46,9,46,41,1],[47,9,47,41,1],[48,9,48,41,1],[49,9,49,41,1],[50,9,50,35,1],[53,9,53,34,1],[54,9,54,34,1],[55,9,55,36,1],[56,9,56,34,1],[59,9,59,34,1],[60,9,60,34,1],[61,9,61,34,1],[62,9,62,36,1],[65,9,65,31,1],[66,9,66,31,1],[67,5,67,6,1],[71,5,71,6,1],[73,9,78,11,1],[81,9,81,91,1],[84,9,84,41,1],[85,9,85,41,1],[86,9,86,41,1],[87,9,87,41,1],[88,9,88,35,1],[91,9,91,34,1],[92,9,92,34,1],[93,9,93,34,1],[94,9,94,42,1],[95,9,95,34,1],[96,9,96,34,1],[97,9,97,42,1],[98,9,98,42,1],[99,9,99,34,0],[102,9,102,34,0],[103,9,103,34,0],[104,9,104,34,0],[105,9,105,34,0],[106,9,106,43,0],[107,9,107,44,0],[108,9,108,34,0],[109,9,109,34,0],[110,9,110,34,0],[113,9,113,31,0],[114,9,114,31,0],[115,9,115,31,0],[116,5,116,6,0],[120,5,120,6,1],[122,9,127,11,1],[130,9,130,91,1],[133,9,133,41,0],[134,9,134,41,0],[135,9,135,41,0],[136,9,136,41,0],[137,9,137,35,0],[140,9,140,34,0],[141,9,141,34,0],[142,9,142,34,0],[143,9,143,34,0],[144,9,144,34,0],[145,9,145,34,0],[146,9,146,34,0],[147,9,147,34,0],[148,9,148,34,0],[151,9,151,34,0],[152,9,152,34,0],[153,9,153,34,0],[154,9,154,34,0],[155,9,155,34,0],[156,9,156,34,0],[157,9,157,34,0],[158,9,158,34,0],[159,9,159,34,0],[162,9,162,31,0],[163,9,163,31,0],[164,9,164,31,0],[165,5,165,6,0],[174,5,174,6,1],[176,9,176,45,1],[177,14,177,23,1],[177,25,177,30,1],[177,32,177,35,1],[178,18,178,27,1],[178,29,178,34,1],[178,36,178,39,1],[179,17,179,42,1],[182,9,182,60,1],[185,9,185,84,1],[186,9,186,39,1],[188,14,188,23,1],[188,25,188,30,1],[188,32,188,35,1],[189,9,189,10,1],[190,13,190,91,1],[191,13,191,44,1],[193,18,193,27,1],[193,29,193,34,1],[193,36,193,39,1],[194,13,194,14,1],[195,17,195,65,1],[196,13,196,14,1],[197,9,197,10,1],[198,5,198,6,1],[202,5,202,6,1],[204,9,208,11,1],[211,9,211,60,1],[214,9,214,52,1],[215,9,215,40,1],[216,5,216,6,1],[225,5,225,6,1],[228,9,228,66,1],[231,9,231,84,1],[232,9,232,39,1],[234,14,234,23,1],[234,25,234,30,1],[234,32,234,35,1],[235,9,235,10,1],[236,13,236,91,1],[237,13,237,44,1],[239,18,239,27,1],[239,29,239,34,1],[239,36,239,39,1],[240,13,240,14,1],[241,17,241,64,1],[242,13,242,14,1],[243,9,243,10,1],[244,5,244,6,1],[248,5,248,6,1],[250,9,250,53,1],[253,9,253,48,1],[253,48,253,103,1],[253,103,253,105,1],[254,5,254,6,0]]);
    </script>
  </body>
</html>